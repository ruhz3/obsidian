C와 C++이 **플랫폼 의존성**을 갖는 이유는 다음과 같습니다.

---

## **1. 컴파일 및 빌드 과정**

C와 C++은 **컴파일 언어**로, 소스 코드가 플랫폼별 **컴파일러**를 통해 **기계어**로 변환됩니다.

- **컴파일러 차이**: 각 플랫폼(운영체제 및 하드웨어)에 따라 컴파일러가 생성하는 기계어 코드가 다릅니다.
- **링커 차이**: 링커는 플랫폼의 시스템 라이브러리를 참조하며, 운영체제에 따라 이 과정이 상이합니다.

### 예제:

- Windows: MSVC(Visual Studio) 컴파일러
- Linux: GCC, Clang

동일한 코드라도 각 플랫폼에 맞는 컴파일러로 다시 빌드해야 합니다.

---

## **2. 운영체제(API) 의존성**

C와 C++은 운영체제의 시스템 호출(예: 파일 입출력, 소켓 통신 등)에 직접 접근할 수 있습니다.

- 운영체제별로 제공하는 API가 다르므로 코드가 플랫폼에 따라 달라질 수 있습니다.

### 예제: 파일 시스템 접근

```cpp
// Windows
#include <windows.h>
CreateFile(...);

// Linux
#include <fcntl.h>
open(...);
```

위 코드처럼 OS별 API가 다르기 때문에 소스 코드가 운영체제에 의존하게 됩니다.

---

## **3. 하드웨어 및 아키텍처 차이**

프로세서 아키텍처(x86, ARM 등)와 데이터 정렬 방식, 메모리 정렬 규칙 등이 다르기 때문에 코드 실행 방식에 차이가 발생할 수 있습니다.

- 예: 빅엔디언 vs 리틀엔디언
- 메모리 정렬과 포인터 크기(32비트 vs 64비트)의 차이

---

## **4. 라이브러리 및 링크 의존성**

C와 C++은 표준 라이브러리 외에도 OS 또는 서드파티 라이브러리에 의존하는 경우가 많습니다.

- Windows의 DLL(dynamic link library)
- Linux의 .so(shared object)

이러한 라이브러리 파일 형식과 동작 방식이 플랫폼별로 다르므로 재컴파일과 재링킹이 필요합니다.

---

## **5. 시스템 호출과 인터럽트 처리**

C와 C++은 로우 레벨 프로그래밍을 지원하기 때문에, 하드웨어 및 시스템 호출과 밀접하게 연관됩니다.

- 시스템 호출 인터페이스가 플랫폼마다 다르므로 코드 수정이 필요합니다.

---

### **결론**

C와 C++의 플랫폼 의존성은 주로 **컴파일러, OS API, 하드웨어 차이, 라이브러리 시스템** 때문입니다.  
이 문제를 해결하려면 **크로스 컴파일** 또는 **플랫폼 독립적 라이브러리**(예: Boost, Qt)를 활용하거나, 운영체제 추상화 레이어를 구현하는 방식이 필요합니다.